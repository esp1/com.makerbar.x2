cmdhistory=[";; Switching to x2-client.core namespace" "(require 'aleph.core)" "(require 'aleph.tcp)" "(use 'clojure.repl)" "(dir aleph.tcp)" "(require 'lamina.core)" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"192.168.7.2\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(enqueue ch \\"Hello, server\!\\")" "(wait-for-message ch)" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (enqueue ch \\"Hello, server\!\\")\\n  (println \\"received\:\\" (wait-for-message ch)))" "(echo-client)" "(echo-client 1\\n             )" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.7.2\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n  (enqueue ch x)\\n  (println \\"received\:\\" (wait-for-message ch)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.7.2\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hi\\")" "(echo-client \\"ariba\\")" "(apply echo-client (repeat 5 \\"hi\\"))" "(doseq [n (range 5)]\\n  (echo-client n))" "(doseq [n (range 5)]\\n  (println (echo-client (str \\"message \\" n))))" "(echo-client \\"This is supposed to be a really long message lets see how many bytes I can reasonably send\\")" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" ";; Switching to x2-client.core namespace" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client \\"ariba\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"localhost\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"ariba\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.1.140\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"ariba\\")" ";; Switching to x2-client.core namespace" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hi\\")" "(echo-client \\"hiya\\")" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client \\"hiya\\")" "(count \\"abc\\")" "(echo-client \\"hiya\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya\\")" "(echo-client \\"hiya doin?\\")" "(defcodec f (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec f (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f [(string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f [\:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f \:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(defcodec f \:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defcodec example-codec\\n  [\:id       \:uint32\\n   \:msg-type (enum \:byte {\:a \\\\A, \:b \\\\B})\\n   \:status   (string \:ascii \:length 11)])" "(def buffer (byte-array 16))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec example-codec\\n  [\:id       \:uint32\\n   \:msg-type (enum \:byte {\:a \\\\A, \:b \\\\B})\\n   \:status   (string \:ascii \:length 11)])" "(def buffer (byte-array 16))" "(dir gloss.core)" "(encode example-codec {\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"})" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [gloss.io \:refer [decode encode]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(encode example-codec {\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"})" "example-codec" "(encode example-codec [\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"])" "(defcodec x2-codec\\n  \:int32\\n  (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defcodec x2-frame\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"abc\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch [(count x) x])\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"abc\\")" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch [(count x) x])\\n    (println \\"received\:\\" (wait-for-message ch))))" "(encode x2-codec [3 \\"abc\\"])" "(String. (encode x2-codec [3 \\"abc\\"]))" "(String. (.array (encode x2-codec [3 \\"abc\\"])))" "(str (encode x2-codec [3 \\"abc\\"]))" "(str (first (encode x2-codec [3 \\"abc\\"])))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(encode-to-buffer x2-codec [3 \\"abc\\"])" "(use 'gloss.io)" "(encode-to-stream x2-codec java.lang.System/out [3 \\"abc\\"])" "(encode-to-stream x2-codec java.lang.System/out 3 \\"abc\\")" "(encode-to-stream x2-codec java.lang.System/out (seq 3 \\"abc\\"))" "(encode-to-stream x2-codec java.lang.System/out (seq [3 \\"abc\\"]))" "(defcodec x-codec [\:int32])" "(encode-to-stream java.lang.System/out 3)" "(encode-to-stream x-codec java.lang.System/out 3)" "(encode-to-stream x-codec java.lang.System/out (int 3))" "(encode-to-stream x-codec java.lang.System/out [3])" "(encode-to-stream x-codec java.lang.System/out [[3]])" "(defcodec x-codec (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(encode-to-stream x-codec java.lang.System/out \\"abc\\")" "(encode-to-stream x-codec java.lang.System/out '(\\"abc\\"))" "(defcodec x-codec \:int32)" "(encode-to-stream x-codec java.lang.System/out '(3))" "(encode-to-stream x-codec java.lang.System/out '((int 3)))" "(encode-to-stream x-codec java.lang.System/out [(int 3)])" "(defcodec x-codec \:byte)" "(encode-to-stream x-codec java.lang.System/out [\\\\a])" "(defcodec x-codec \:int32)" "(encode-to-stream x-codec java.lang.System/out [132])" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple client\\"\\n  [x]\\n  (let [send-ch (tcp-client {\:host \\"192.168.0.8\\",\\n                             \:port 10000,\\n                             \:frame x2-frame})]\\n    (enqueue send-ch [(count x) x])\\n    (println \\"sent\\")))" "(echo-client \\"yay\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client \\"yay\\")" "(echo-client \\"yay whatever\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(int (count x)) x])\\n    ))" "(echo-client \\"a\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [70000 x])\\n    ))" "(echo-client \\"a\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client \\"a\\")" "(echo-client \\"ab\\")" "(echo-client \\"abc\\")" "(echo-client \\"whatever\\")" "(defcodec x2-codec\\n  (repeated \:byte))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client (byte-array 1 132))" "(echo-client 132)" "(echo-client [132])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client [132])" "(echo-client [132 132 132 132])" "(defcodec x2-codec\\n  (repeated \:byte))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (repeated \:byte))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client [132 132 132 132])" "(echo-client (byte 132))" "(echo-client (byte 1))" "(echo-client [(byte 1)])" "(echo-client [(byte 100)])" "(echo-client [(byte 100 128)])" "(echo-client (byte-array (map byte [100 128])))" "(echo-client (byte-array (map byte [100 127])))" "(echo-client (map byte [100 127]))" "(echo-client (map byte [100 121]))" "(echo-client (map byte [\\\\a]))" "(echo-client \\"how are you?\\")" "(echo-client (map byte \\"how are you?\\"))" "(byte 127)" "(byte -1)" "(bit-shift-left (byte -1))" "(bit-shift-left (byte -1) 1)" "(bit-shift-right (byte -1) 1)" "(bit-shift-left (byte -1) 7)" "(bit-shift-left (byte -1) 8)" "(byte (bit-shift-left (byte -1) 8))" "(byte (bit-shift-left (byte -1) 7))" "(bit-shift-right (byte -1) 8)" "(byte 0xF)" "(byte 0xFF)" "(defcodec x2-codec\\n  (repeated \:byte \:delimiters [\\\\0]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (repeated \:byte \:prefix \:int32 \:delimiters [\\\\0]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum header repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (repeated \:byte))" "(defcodec x2-codec\\n  (header \:byte\\n          \#(repeated \:byte)\\n          \:x2))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \:x2)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(echo-client (map byte \\"sup\\"))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum finite-frame header repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (finite-frame (repeated \:byte \:prefix \:none)))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (finite-frame \:int32 (repeated \:byte \:prefix \:none)))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.56.1\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" ";; Switching to x2-client.core namespace" "(str (.toURI (java.io.File \\"repo\\")))" "(str (.toURI (java.io.File. \\"repo\\")))" "(clojure.core/ns x2-client.test)\\n(ns x2-client.test\\n  (\:gen-class\\n    \:extends processing.core.PApplet\\n    \:main true))\\n(clojure.core/ns user)" "(clojure.core/ns x2-client.test)\\n(defn -main\\n  [& args]\\n  (x2-client.test.))\\n(clojure.core/ns user)" "(clojure.core/ns x2.client.test)\\n(ns x2.client.test\\n  (\:gen-class\\n    \:extends processing.core.PApplet\\n    \:main true))\\n(clojure.core/ns user)" "(clojure.core/ns x2.client.test)\\n(defn -main\\n  [& args]\\n  (x2.client.test.))\\n(clojure.core/ns user)" ";; Switching to x2.client.test namespace" "(-main)" "(defn -draw\\n  [this]\\n  (.background this 100))" "(defn -main\\n  [& args]\\n  (processing.core.PApplet/main \\"x2.client.test\\"))" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" "(defn -setup\\n  [this]\\n  (.size this 800 600)\\n  \\n;  (doseq [s (processing.serial.Serial/list)]\\n;    (println s))\\n  (doseq [c (processing.video.Capture/list)]\\n    (println c)))" "(defn -main\\n  [& args]\\n  (processing.core.PApplet/main \\"x2.client.test\\"))" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" "(def rotation-direction \:counterclockwise)" "(def sector-width 56)" "sector-width" ";; Switching to x2.client.test namespace" "rotation-direction" "sector-width" "num-sector-columns" "sector-height" "sector-rows" "(pov-width)" "(pov-height)" "(def pov-width (* num-sector-columns sector-width))" "(def pov-height (* (count sector-rows) sector-height))" "pov-width" "pov-height" "(defn -setup\\n  [this]\\n  (.size this 800 600)\\n  \\n  (def pg (.createGraphics this pov-width pov-height))\\n  (def ximg (.createImage this pov-width pov-height processing.core.PConstants/ARGB))\\n  \\n  (doseq [s (processing.serial.Serial/list)]\\n    (println s))\\n  (doseq [c (processing.video.Capture/list)]\\n    (println c)))" "(defn foo []\\n  (def x 5))" "x" "(foo)" "x" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\n\\n                   \\"----\\n                    l \: re/load properties\\n                    o \: open image file\\n                    c \: capture video\\n                    ----\\")" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\n\\n                   \\"\\n----\\n\\nl \: re/load properties\\no \: open image file\\nc \: capture video\\n\\n----\\")" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\newline\\n                   \\"\\n----\\n\\nl \: re/load properties\\no \: open image file\\nc \: capture video\\n\\n----\\")" "(class 20)" ";; Switching to x2.client.test namespace" "(class 20)" "(class 20.0)" "(class 20.0f\\n       )" ";; Switching to com.makerbar.x2.client namespace" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (gloss.core/string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(enqueue ch \\"Hello server\\")" "(wait-for-message ch)" "(lamina.re/wait-for-message ch)" "(lamina.core/wait-for-message ch)" ";; Switching to com.makerbar.x2.client namespace" "(x2-client 1)" "(x2-client (seq 1))" "(x2-client [1])" "(x2-client [1 2])" "(x2-client [1 2 3])" "(defcodec x2-codec\\n  (repeated \:int32))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4])" "(x2-client [1 2 3 4 5 6 7])" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:int32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(doc atoi)" "(java.lang.Integer/parseInt \\\\0)" "(java.lang.Integer/parseInt (str \\\\0))" "(x2-client [1 2 3 4 5 6 7])" "\\\\" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4 5 6 7])" "(\#(str \\"hi\\" %) \\"ther\\")" "(\#(list %1 %2)  1 2)" " (\#(identity {%1 %2})  1 2)" "(\#(array-map %1 %2)  1 2)" "(\#(set %1 %2)  1 2)" "(set 1 2)" "(set [1 1 2 3])" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:int32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4 5 6 7])" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:int32-be))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4 5 6 7])" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4 5 6 7])" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" "(x2-client [1 2 3 4 5 6 7])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data)\\n      (wait-for-message ch))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data)\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6 7])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data)\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6 7])" "(gloss.io/encode x2-codec [1 2 3])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]) (wait-for-result ch)))))" "(ns com.makerbar.x2.client\\n  (\:gen-class\\n    \:name com.makerbar.x2.X2Client\\n    \:methods [\#^{\:static true} [sendData [processing.core.PImage] void]])\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [decode defcodec encode header repeated]]\\n            [lamina.core \:refer [enqueue wait-for-result]]))" "(ns com.makerbar.x2.client\\n  (\:gen-class\\n    \:name com.makerbar.x2.X2Client\\n    \:methods [\#^{\:static true} [sendData [processing.core.PImage] void]])\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec header repeated]]\\n            [gloss.io \:refer [decode encode]]\\n            [lamina.core \:refer [enqueue wait-for-result]]))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]) (wait-for-result ch)))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]) (wait-for-result ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (wait-for-result ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch data)\\n      (wait-for-result ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      )))" "(x2-client [1 2 3 4 5 6])" "(defn -sendData\\n  [pimage]\\n  (let [data (seq (.pixels pimage))]\\n    (println (count data))\\n    (x2-client data)))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (string) (lamina.core/wait-for-message ch)))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/string) (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]) (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/compile-frame \:uint64) (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(ns com.makerbar.x2.client\\n  (\:gen-class\\n    \:name com.makerbar.x2.X2Client\\n    \:methods [\#^{\:static true} [sendData [processing.core.PImage] void]])\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec header repeated]]\\n            [gloss.io \:refer [decode encode]]\\n            [lamina.core \:refer [enqueue wait-for-message]]))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/compile-frame \:uint64) (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/compile-frame {\:a \:uint64}) (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode-channel (lamina.core/wait-for-message ch) (gloss.core/compile-frame {\:a \:uint64})))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel (lamina.core/wait-for-message ch) (gloss.core/compile-frame {\:a \:uint64})))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel ch (gloss.core/compile-frame {\:a \:uint64})))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode (gloss.core/compile-frame {\:a \:uint64}) (lamina.core/wait-for-message ch)))))" "(defcodec receive-codec\\n  {\:a \:uint64})" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(pst *e)" "(use 'clojure.repl)" "(pst *e)" "(x2-client [1 2 3 4 5 6])" "(pst *e)" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/read-bytes receive-codec (lamina.core/wait-for-message ch)))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.core.protocols/read-bytes receive-codec (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (java.nio.ByteBuffer/wrap (lamina.core/wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (java.nio.ByteBuffer/wrap (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (lamina.core/wait-for-message ch))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/to-byte-buffer (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (.toByteBuffer (lamina.core/wait-for-message ch)))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (.toByteBuffer (lamina.core/wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6])" "(defcodec receive-codec\\n  {\:a \:uint64-le})" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (.toByteBuffer (lamina.core/wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6])" "(defcodec receive-codec\\n  {\:uint64-le})" "(defcodec receive-codec\\n  [\:uint64-le])" "(x2-client [1 2 3 4 5 6])" "(defcodec receive-codec\\n  \:uint64-le)" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode-channel ch receive-codec))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel ch receive-codec))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel (read-channel ch) receive-codec))))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel (lamina.core/read-channel ch) receive-codec))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (gloss.io/decode-channel (wait-for-message (lamina.core/read-channel ch)) receive-codec))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (wait-for-message (lamina.core/read-channel ch)) receive-codec)))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (.toByteBuffer (wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch \\n               (tcp-client {\:host host\\n                            \:port port})]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (.toByteBuffer (wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6])" "(defn x2-client\\n  \\"X2 client\\"\\n  ([data] (x2-client \\"localhost\\" 10000 data))\\n  ([host data] (x2-client host 10000 data))\\n  ([host port data]\\n    (let [ch (wait-for-result (tcp-client {\:host host, \:port port}))]\\n      (enqueue ch (encode send-codec data))\\n      (decode receive-codec (.toByteBuffer (wait-for-message ch))))))" "(x2-client [1 2 3 4 5 6 7 8 9 10])" ";; Switching to com.makerbar.x2.client namespace" "(x2-client [1 2 3 4 5])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(x2-client [1 2 3 4 5])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-be))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(x2-client [1 2 3 4 5])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(x2-client [1 2 3 4 5])" "(encode send-codec 1)" "(encode send-codec [1])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(encode send-codec [1])" "(println (encode send-codec [1]))" "(.bytes (encode send-codec [1]))" "(seq (encode send-codec [1]))" "(map pr (seq (encode send-codec [1])))" "(.array (encode send-codec [1]))" "(take-while true (encode send-codec [1]))" "(take-while \#(true) (encode send-codec [1]))" "(take-while \#(\= % %) (encode send-codec [1]))" "(first (encode send-codec [1]))" "(.array (first (encode send-codec [1])))" "(seq (.array (first (encode send-codec [1]))))" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(seq (.array (first (encode send-codec [1]))))" ";; Switching to com.makerbar.x2.client namespace" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32-le))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(seq (.array (first (encode send-codec [1]))))" "(x2-client [1 2 3 4])" "(x2-client [1 2 3 4 5])" "(defcodec send-codec\\n  (header \:byte\\n          (fn [h] (repeated \:uint32))  ; body is repeated bytes, with int32 length prefix \\n          (fn [b] \\\\0)))" "(x2-client [1 2 3 4 5 6 7])" "(/ (x2-client [1 2 3 4 5 6 7]) 1000)" "(/ (x2-client [1 2 3 4 5 6 7]) 1000000)" "(class (x2-client [1 2 3 4 5 6 7]))" "(long (x2-client [1 2 3 4 5 6 7]))"]
eclipse.preferences.version=1
