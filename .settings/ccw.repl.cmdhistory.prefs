cmdhistory=[";; Switching to x2-client.core namespace" "(require 'aleph.core)" "(require 'aleph.tcp)" "(use 'clojure.repl)" "(dir aleph.tcp)" "(require 'lamina.core)" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"localhost\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(def ch\\n  (wait-for-result\\n    (tcp-client {\:host \\"192.168.7.2\\",\\n                 \:port 10000,\\n                 \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])})))" "(enqueue ch \\"Hello, server\!\\")" "(wait-for-message ch)" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (enqueue ch \\"Hello, server\!\\")\\n  (println \\"received\:\\" (wait-for-message ch)))" "(echo-client)" "(echo-client 1\\n             )" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.7.2\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n  (enqueue ch x)\\n  (println \\"received\:\\" (wait-for-message ch)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.7.2\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hi\\")" "(echo-client \\"ariba\\")" "(apply echo-client (repeat 5 \\"hi\\"))" "(doseq [n (range 5)]\\n  (echo-client n))" "(doseq [n (range 5)]\\n  (println (echo-client (str \\"message \\" n))))" "(echo-client \\"This is supposed to be a really long message lets see how many bytes I can reasonably send\\")" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" ";; Switching to x2-client.core namespace" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client \\"ariba\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"localhost\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"ariba\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.1.140\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"ariba\\")" ";; Switching to x2-client.core namespace" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hi\\")" "(echo-client \\"hiya\\")" "(echo-client (str \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"\\n                  \\"This is supposed to be a really long message lets see how many bytes I can reasonably send okay...\\"))" "(echo-client \\"hiya\\")" "(count \\"abc\\")" "(echo-client \\"hiya\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya\\")" "(echo-client \\"hiya doin?\\")" "(defcodec f (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec f (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f [(string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f [\:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defcodec f \:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (str (count x) x))\\n    (println \\"received\:\\" (wait-for-message ch))))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"hiya doin?\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame f}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(defcodec f \:int32 (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defcodec example-codec\\n  [\:id       \:uint32\\n   \:msg-type (enum \:byte {\:a \\\\A, \:b \\\\B})\\n   \:status   (string \:ascii \:length 11)])" "(def buffer (byte-array 16))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec example-codec\\n  [\:id       \:uint32\\n   \:msg-type (enum \:byte {\:a \\\\A, \:b \\\\B})\\n   \:status   (string \:ascii \:length 11)])" "(def buffer (byte-array 16))" "(dir gloss.core)" "(encode example-codec {\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"})" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [gloss.io \:refer [decode encode]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(encode example-codec {\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"})" "example-codec" "(encode example-codec [\:id 42, \:msg-type \:a, \:status \\"A-OKAY\\"])" "(defcodec x2-codec\\n  \:int32\\n  (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defcodec x2-frame\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch (count x) x)\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"abc\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch [(count x) x])\\n    (println \\"received\:\\" (wait-for-message ch))))" "(echo-client \\"abc\\")" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-frame}))]\\n    (enqueue ch [(count x) x])\\n    (println \\"received\:\\" (wait-for-message ch))))" "(encode x2-codec [3 \\"abc\\"])" "(String. (encode x2-codec [3 \\"abc\\"]))" "(String. (.array (encode x2-codec [3 \\"abc\\"])))" "(str (encode x2-codec [3 \\"abc\\"]))" "(str (first (encode x2-codec [3 \\"abc\\"])))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(encode-to-buffer x2-codec [3 \\"abc\\"])" "(use 'gloss.io)" "(encode-to-stream x2-codec java.lang.System/out [3 \\"abc\\"])" "(encode-to-stream x2-codec java.lang.System/out 3 \\"abc\\")" "(encode-to-stream x2-codec java.lang.System/out (seq 3 \\"abc\\"))" "(encode-to-stream x2-codec java.lang.System/out (seq [3 \\"abc\\"]))" "(defcodec x-codec [\:int32])" "(encode-to-stream java.lang.System/out 3)" "(encode-to-stream x-codec java.lang.System/out 3)" "(encode-to-stream x-codec java.lang.System/out (int 3))" "(encode-to-stream x-codec java.lang.System/out [3])" "(encode-to-stream x-codec java.lang.System/out [[3]])" "(defcodec x-codec (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"]))" "(encode-to-stream x-codec java.lang.System/out \\"abc\\")" "(encode-to-stream x-codec java.lang.System/out '(\\"abc\\"))" "(defcodec x-codec \:int32)" "(encode-to-stream x-codec java.lang.System/out '(3))" "(encode-to-stream x-codec java.lang.System/out '((int 3)))" "(encode-to-stream x-codec java.lang.System/out [(int 3)])" "(defcodec x-codec \:byte)" "(encode-to-stream x-codec java.lang.System/out [\\\\a])" "(defcodec x-codec \:int32)" "(encode-to-stream x-codec java.lang.System/out [132])" "(defcodec x2-codec\\n  [\:int32\\n   (string \:utf-8 \:delimiters [\\"\\\\r\\\\n\\"])])" "(defn echo-client\\n  \\"A simple client\\"\\n  [x]\\n  (let [send-ch (tcp-client {\:host \\"192.168.0.8\\",\\n                             \:port 10000,\\n                             \:frame x2-frame})]\\n    (enqueue send-ch [(count x) x])\\n    (println \\"sent\\")))" "(echo-client \\"yay\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client \\"yay\\")" "(echo-client \\"yay whatever\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(int (count x)) x])\\n    ))" "(echo-client \\"a\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [70000 x])\\n    ))" "(echo-client \\"a\\")" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client \\"a\\")" "(echo-client \\"ab\\")" "(echo-client \\"abc\\")" "(echo-client \\"whatever\\")" "(defcodec x2-codec\\n  (repeated \:byte))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch [(count x) x])\\n    ))" "(echo-client (byte-array 1 132))" "(echo-client 132)" "(echo-client [132])" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client [132])" "(echo-client [132 132 132 132])" "(defcodec x2-codec\\n  (repeated \:byte))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (repeated \:byte))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client [132 132 132 132])" "(echo-client (byte 132))" "(echo-client (byte 1))" "(echo-client [(byte 1)])" "(echo-client [(byte 100)])" "(echo-client [(byte 100 128)])" "(echo-client (byte-array (map byte [100 128])))" "(echo-client (byte-array (map byte [100 127])))" "(echo-client (map byte [100 127]))" "(echo-client (map byte [100 121]))" "(echo-client (map byte [\\\\a]))" "(echo-client \\"how are you?\\")" "(echo-client (map byte \\"how are you?\\"))" "(byte 127)" "(byte -1)" "(bit-shift-left (byte -1))" "(bit-shift-left (byte -1) 1)" "(bit-shift-right (byte -1) 1)" "(bit-shift-left (byte -1) 7)" "(bit-shift-left (byte -1) 8)" "(byte (bit-shift-left (byte -1) 8))" "(byte (bit-shift-left (byte -1) 7))" "(bit-shift-right (byte -1) 8)" "(byte 0xF)" "(byte 0xFF)" "(defcodec x2-codec\\n  (repeated \:byte \:delimiters [\\\\0]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (repeated \:byte \:prefix \:int32 \:delimiters [\\\\0]))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum header repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (repeated \:byte))" "(defcodec x2-codec\\n  (header \:byte\\n          \#(repeated \:byte)\\n          \:x2))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \:x2)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"how are you?\\"))" "(echo-client (map byte \\"sup\\"))" "(ns x2-client.core\\n  (\:require [aleph.tcp \:refer [tcp-client]]\\n            [gloss.core \:refer [defcodec enum finite-frame header repeated string]]\\n            [gloss.io \:refer [decode encode-to-buffer]]\\n            [lamina.core \:refer [enqueue wait-for-message wait-for-result]]))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (finite-frame (repeated \:byte \:prefix \:none)))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (finite-frame \:int32 (repeated \:byte \:prefix \:none)))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defcodec x2-codec\\n  (header \:byte\\n          (fn [h] (repeated \:byte))\\n          (fn [b] \\\\0)))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.0.8\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(echo-client (map byte \\"sup\\"))" "(defn echo-client\\n  \\"A simple echo client\\"\\n  [x]\\n  (let [ch (wait-for-result\\n             (tcp-client {\:host \\"192.168.56.1\\",\\n                          \:port 10000,\\n                          \:frame x2-codec}))]\\n    (enqueue ch x)\\n    ))" "(defn x2-client\\n  \\"X2 client\\"\\n  ([panel-data] (x2-client \\"localhost\\" 10000 panel-data))\\n  ([host panel-data] (x2-client host 10000 panel-data))\\n  ([host port panel-data]\\n    (let [ch (wait-for-result\\n               (tcp-client {\:host host\\n                            \:port port\\n                            \:frame x2-codec}))]\\n      (enqueue ch panel-data))))" ";; Switching to x2-client.core namespace" "(str (.toURI (java.io.File \\"repo\\")))" "(str (.toURI (java.io.File. \\"repo\\")))" "(clojure.core/ns x2-client.test)\\n(ns x2-client.test\\n  (\:gen-class\\n    \:extends processing.core.PApplet\\n    \:main true))\\n(clojure.core/ns user)" "(clojure.core/ns x2-client.test)\\n(defn -main\\n  [& args]\\n  (x2-client.test.))\\n(clojure.core/ns user)" "(clojure.core/ns x2.client.test)\\n(ns x2.client.test\\n  (\:gen-class\\n    \:extends processing.core.PApplet\\n    \:main true))\\n(clojure.core/ns user)" "(clojure.core/ns x2.client.test)\\n(defn -main\\n  [& args]\\n  (x2.client.test.))\\n(clojure.core/ns user)" ";; Switching to x2.client.test namespace" "(-main)" "(defn -draw\\n  [this]\\n  (.background this 100))" "(defn -main\\n  [& args]\\n  (processing.core.PApplet/main \\"x2.client.test\\"))" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" "(defn -setup\\n  [this]\\n  (.size this 800 600)\\n  \\n;  (doseq [s (processing.serial.Serial/list)]\\n;    (println s))\\n  (doseq [c (processing.video.Capture/list)]\\n    (println c)))" "(defn -main\\n  [& args]\\n  (processing.core.PApplet/main \\"x2.client.test\\"))" "(-main)" ";; Switching to x2.client.test namespace" "(-main)" "(def rotation-direction \:counterclockwise)" "(def sector-width 56)" "sector-width" ";; Switching to x2.client.test namespace" "rotation-direction" "sector-width" "num-sector-columns" "sector-height" "sector-rows" "(pov-width)" "(pov-height)" "(def pov-width (* num-sector-columns sector-width))" "(def pov-height (* (count sector-rows) sector-height))" "pov-width" "pov-height" "(defn -setup\\n  [this]\\n  (.size this 800 600)\\n  \\n  (def pg (.createGraphics this pov-width pov-height))\\n  (def ximg (.createImage this pov-width pov-height processing.core.PConstants/ARGB))\\n  \\n  (doseq [s (processing.serial.Serial/list)]\\n    (println s))\\n  (doseq [c (processing.video.Capture/list)]\\n    (println c)))" "(defn foo []\\n  (def x 5))" "x" "(foo)" "x" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\n\\n                   \\"----\\n                    l \: re/load properties\\n                    o \: open image file\\n                    c \: capture video\\n                    ----\\")" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\n\\n                   \\"\\n----\\n\\nl \: re/load properties\\no \: open image file\\nc \: capture video\\n\\n----\\")" "(str \\"Display dimensions\: \\" pov-width \\" x \\" pov-height \\\\newline\\n                   \\"\\n----\\n\\nl \: re/load properties\\no \: open image file\\nc \: capture video\\n\\n----\\")" "(class 20)" ";; Switching to x2.client.test namespace" "(class 20)" "(class 20.0)" "(class 20.0f\\n       )"]
eclipse.preferences.version=1
